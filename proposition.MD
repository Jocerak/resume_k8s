## sujet : Je suis un √©tudiant qui manque de budget


# CHAPITRE 1
<ins>**solution**
1. Mettre la solution en local (installer sur votre PC) 
2. Virtualiser une machine linux sur votre PC physique windows,
3. installer tout les prerecquis 
    - installer Minikube sur votre VM vous pouvez suivre le lien du site officiel clique [ici](https://minikube.sigs.k8s.io/docs/start)
    
    En premier lieu on va voir c'est quoi minikube 
    > Minikube est un Kubernetes local, ax√© sur la facilit√© d'apprentissage et de d√©veloppement pour Kubernetes.

    Tout ce dont vous avez besoin, c'est d'un conteneur Docker * (ou similaire compatible) ou d'un environnement de machine virtuelle

    - Pour verifier si l'installation et bien faite faire une verifiation en executant les commandes suivant:
        `minikube --help`
    
    - [documentation pour l'installation kubectl](https://kubernetes.io/fr/docs/tasks/tools/install-kubectl/)
     Coller cette commande pour votre terminal pour l'intaller 
```bash
sudo apt-get update && sudo apt-get install -y apt-transport-https
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
echo "deb https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee -a /etc/apt/sources.list.d/kubernetes.list
sudo apt-get update
sudo apt-get install -y kubectl 
```
Pour le verifier executer la commande `kubectl --help`

Etape suivant on va deployer une  machine ou node mais on peux deployer plusieurs machine mais on verra √ßa apr√®s 

Pour creer c'est juste de taper `Minikube start` sur votre terminal il va creer un cluster 
un cluster c'est quoi ? *Cluster ce sont des machines preconfigurer*


*Retour* 

>üòÑ  minikube v1.34.0 sur Ubuntu 24.04
‚ú®  Choix automatique du pilote docker
üìå  Utilisation du pilote Docker avec le privil√®ge root
üëç  D√©marrage du n≈ìud "minikube" primary control-plane dans le cluster "minikube"
üöú  Extraction de l'image de base v0.0.45...
üî•  Cr√©ation de docker container (CPU=2, Memory=3900Mo) ...
üê≥  Pr√©paration de Kubernetes v1.31.0 sur Docker 27.2.0...
    ‚ñ™ G√©n√©ration des certificats et des cl√©s
    ‚ñ™ D√©marrage du plan de contr√¥le ...
    ‚ñ™ Configuration des r√®gles RBAC ...
üîó  Configuration de bridge CNI (Container Networking Interface)...
üîé  V√©rification des composants Kubernetes...
    ‚ñ™ Utilisation de l'image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Modules activ√©s: default-storageclass, storage-provisioner
üèÑ  Termin√© ! kubectl est maintenant configur√© pour utiliser "minikube" cluster et espace de noms "default" par d√©faut.

Maintenant on va r√©partir les d√©ploiements sur deux machines (nodes) 

Avant de commencer :

On supprime le cluster sur l'ancien deployment ; pour le faire execute `minikube delete` sur votre terminal 

Recr√©er le cluster avec 2 machines

Creer 2 machines (nodes) =>`minikube start --nodes 2`  

Pour afficher le status des 2 nodes =>`minikube status`

Maintenant on va deployer une image sur notre machine 



`kubectl create deployment myserver --replicas 2 --image=kicbase/echo-server:1.0 `
=> explication de cette commande 
kubectl create deployment myserver  => *creer un deployment qui s'appelle myserveur*
`--replicas 2` => *creer 2 machine*
`kubectl get pods`*affiche les pods*
`kubectl get deployment`=> *affiche les deployments*
`kubectl get services` => *affiche les services*

`kubectl get pods -o wide`*affiche le status en version plus d√©taill√© 

*Retour* 
| NAME                          | READY | STATUS  | RESTARTS | AGE  | IP           | NODE      | NOMINATED NODE | READINESS GATES |
|-------------------------------|-------|---------|----------|------|--------------|-----------|----------------|-----------------|
| hello-matrix-7d864756b7-4d5r9 | 1/1   | Running | 0        | 17m  | 10.244.0.3   | minikube  | `<none>`       | `<none>`        |

Toute √† l'heure on vu le deployement par ligne de commande 
- Deuxi√®me fa√ßon de deployer des machines 
Par un fichier .yaml 
il y a un exemple de ce fichier a votre disposition 

On peut aussi definir aussi la performance de notre deployement 
par exemple on met 4 cpus et 4096 Mo de memoire

`minikube start --cpus 4 memory 4096` 

### Comment deployer une image docker dans un cluster kubernetes 
##### D√©ployer une application
`kubectl create deployment hello-matrix --image=fredericeducentre/matrix`
=> *deployment.apps/hello-matrix created*

##### Exposer l'application
`kubectl expose deployment hello-matrix --type=NodePort --port=80`
=> *service/hello-matrix exposed*
##### Voir les d√©ploiements et pods
`kubectl get deployment`
| NAME         | READY | UP-TO-DATE | AVAILABLE | AGE   |
|--------------|-------|------------|-----------|-------|
| hello-matrix | 1/1   | 1          | 1         | 3m2s  |

`kubectl get pods`
| NAME                          | READY | STATUS  | RESTARTS | AGE     |
|-------------------------------|-------|---------|----------|---------|
| hello-matrix-7d864756b7-2n9tt  | 1/1   | Running | 0        | 2m47s   |


##### Voir les services
`kubectl get services`
| NAME           | TYPE       | CLUSTER-IP     | EXTERNAL-IP   | PORT(S)        | AGE     |
|---------------|------------|----------------|---------------|----------------|---------|
| hello-matrix  | NodePort   | 10.105.177.234 | <none>        | 80:32119/TCP   | 105s    |
| kubernetes    | ClusterIP  | 10.96.0.1      | <none>        | 443/TCP        | 153m    |

#### Acc√©der au service via Minikube
`minikube service hello-matrix`

| NAMESPACE |     NAME     | TARGET PORT |            URL            |
|-----------|--------------|-------------|---------------------------|
| default   | hello-matrix |          80 | http://192.168.49.2:32119 |

üéâ  Ouverture du service default/hello-matrix dans le navigateur par d√©faut..




# CHAPITRE 2
## Deployment de deux service qui doivent fonctionner ensemble (application et base de donn√©es)

ici on prend comme exemple : on va r√©alis√© un deploiment de Mysql avec Postgres 


Pour d√©ployer ces deux fichiers YAML dans un environnement Kubernetes, vous allez proc√©der en plusieurs √©tapes. Je vais expliquer chacune d'elles, de la cr√©ation des ressources √† leur v√©rification. 

### 1. Pr√©requis
Avant de d√©ployer les fichiers YAML, assurez-vous que :
- Vous avez un cluster Kubernetes fonctionnel.
- Vous avez `kubectl` configur√© pour interagir avec votre cluster.
- Les images Docker (MySQL et WordPress) sont disponibles dans le registre Docker Hub ou un autre registre accessible par Kubernetes.

### 2. D√©ployer la premi√®re partie : MySQL (Base de donn√©es pour WordPress)
Le premier fichier YAML cr√©e deux ressources Kubernetes :
- Un **Service** pour exposer MySQL (port 3306).
- Un **Deployment** pour d√©ployer MySQL avec les variables d'environnement n√©cessaires √† sa configuration.

Voici comment proc√©der pour ce fichier :

#### √âtape 2.1 : Appliquer le fichier YAML
1. Sauvegardez le contenu du premier fichier dans un fichier, par exemple `wordpress-mysql.yaml`.
2. Ex√©cutez la commande suivante pour appliquer le fichier YAML :

```bash
kubectl apply -f wordpress-mysql.yaml
```

Cela va cr√©er :
- Un `Service` nomm√© `wordpress-mysql` exposant le port 3306 pour MySQL.
- Un `Deployment` nomm√© `wordpress-mysql` qui d√©ploie un conteneur MySQL avec les variables d'environnement comme `MYSQL_ROOT_PASSWORD`, `MYSQL_DATABASE`, `MYSQL_USER`, et `MYSQL_PASSWORD`.

#### √âtape 2.2 : V√©rifier le d√©ploiement de MySQL
V√©rifiez si le d√©ploiement de MySQL est bien effectu√© en ex√©cutant :

```bash
kubectl get deployments
kubectl get pods
```

Cela devrait afficher un pod pour `wordpress-mysql` en cours d'ex√©cution.

### 3. D√©ployer la deuxi√®me partie : WordPress (Frontend)
Le deuxi√®me fichier YAML cr√©e √©galement deux ressources Kubernetes :
- Un **Service** pour exposer l'application WordPress via un type `NodePort`.
- Un **Deployment** pour d√©ployer WordPress avec les informations de connexion √† la base de donn√©es MySQL.

Voici comment proc√©der pour ce fichier :

#### √âtape 3.1 : Appliquer le fichier YAML
1. Sauvegardez le contenu du deuxi√®me fichier dans un fichier, par exemple `wordpress.yaml`.
2. Ex√©cutez la commande suivante pour appliquer le fichier YAML :

```bash
kubectl apply -f wordpress.yaml
```

Cela va cr√©er :
- Un `Service` nomm√© `wordpress` exposant le port 80 et le rendant accessible via un `NodePort`.
- Un `Deployment` nomm√© `wordpress` qui d√©ploie un conteneur WordPress avec les variables d'environnement comme `WORDPRESS_DB_HOST`, `WORDPRESS_DB_PASSWORD`, et `WORDPRESS_DB_USER` pointant vers le service MySQL (`wordpress-mysql`).

#### √âtape 3.2 : V√©rifier le d√©ploiement de WordPress
V√©rifiez si le d√©ploiement de WordPress est bien effectu√© en ex√©cutant :

```bash
kubectl get deployments
kubectl get pods
```

Cela devrait afficher un pod pour `wordpress` en cours d'ex√©cution.

### 4. Acc√©der √† WordPress
√âtant donn√© que le service `wordpress` est de type `NodePort`, vous pouvez acc√©der √† votre application WordPress via l'adresse IP du n≈ìud et le port attribu√© √† ce service. Pour trouver ce port, ex√©cutez :

```bash
kubectl get sservices wordpress
```

Vous devriez voir une sortie similaire √† ceci :

```
NAME        TYPE       CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE
wordpress   NodePort   10.96.0.1    <none>        80:30001/TCP   5m
```

Ici, `30001` est le port expos√©, donc vous pouvez acc√©der √† WordPress en ouvrant un navigateur et en acc√©dant √† `http://<node-ip>:30001`.

### 5. V√©rifications finales
- V√©rifiez que les pods pour MySQL et WordPress sont en cours d'ex√©cution :
  ```bash
  kubectl get pods
  ```
  
- V√©rifiez les services expos√©s :
  ```bash
  kubectl get service
  ```

- Si vous rencontrez des probl√®mes, consultez les logs des pods :
  ```bash
  kubectl logs <pod-name>
  ```

### R√©sum√© des commandes principales :
1. Appliquer le fichier de d√©ploiement pour MySQL :
   ```bash
   kubectl apply -f wordpress-mysql.yaml
   ```

2. Appliquer le fichier de d√©ploiement pour WordPress :
   ```bash
   kubectl apply -f wordpress.yaml
   ```

3. V√©rifier les ressources d√©ploy√©es :
   ```bash
   kubectl get deployments
   kubectl get pods
   kubectl get services
   ```


